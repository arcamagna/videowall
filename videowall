#!/bin/env sh

## colours ##

GREEN=$'\e[01;32m'
CYAN=$'\e[01;36m'
RESET=$'\e[0m'


## help ##

help="\n\
${GREEN}Mimics a video wall by creating an overlay filter for ffmpeg.\n\
Works with both videos and images.$RESET
\n\
${CYAN}Usage:$RESET videowall [options] [files..]\n\
\n\
${CYAN}Options:\n\
 $CYAN-n$RESET  <int> Number of rows (max 16). Default 4 (16 tiles) or 3 in portrait mode (18 tiles).\n\
 $CYAN-m$RESET  <int> Maximum number of files. This determines the sequence length before repeating.\n\
 $CYAN-M$RESET  <L|p|P> Display mode for tiles. Landscape mode is used by default.\n\
 	L  Use landscape files only.\n\
 	p  Portrait mode.\n\
 	P  Use portrait files only.\n\
 $CYAN-s$RESET  <int> Skip number of valid files e.g. -s4 use 5th valid file onwards.\n\
 $CYAN-c$RESET    File check (slower start up).\n\
 $CYAN-F$RESET  <int> Target frame rate. Default 30fps.\n\
 $CYAN-r$RESET    Find files recursively.\n\
 $CYAN-f$RESET  <extension> Filter filetype(s) e.g. \"mp4 jpg\".\n\
 $CYAN-t$RESET  <name|tag centre|left> Title type and position. Default no titles.\n\
 $CYAN-d$RESET  <int> Duration in seconds.\n\
 $CYAN-S$RESET    Shuffle file order.
 $CYAN-g$RESET  <\"colour thickness\"> Grid or bezel colour and thickness e.g. \"black 3\". Default is no grid.\n\
 $CYAN-a$RESET  <input_file> File name or tile number for audio source.\n\
 $CYAN-o$RESET  <output_file.mp4> Specify a file name to record output.\n\
 $CYAN-D$RESET    demo\n\
\n\
${CYAN}Files:$RESET\n\
\n\
Directory name or list of videos/images. If omitted current directory is used.\n\
\n\
${CYAN}Operation:$RESET\n\
\n\
If there aren't enough files available or -M restricts the number of files then they will be repeated to fill the given area.\n\
Performance can be very slow for larger values of n especially when mode is L or P or tag is used for title.\n\
\n\
Press q to quit\n\
\n\
${CYAN}Examples:$RESET\n\
\n\
videowall\n\
\n\
4x4 grid of videos and/or images from the current directory. Sequence will be repeated if there aren't 16 unique valid files.\n\
\n\
videowall -Mp -Sn2 -g\"#054da5 4\" -t \"tag centre\"\n\
\n\
8x2 random grid of videos each having a 4 px blue frame and title tag bottom centre if one exists.\n\
\n\
videowall -rs -n6 -f \"mp4 mkv\" -s 50 -o \"/tmp/6x6 video wall.mp4\" ~\n\
\n\
6x6 grid by recursively searching for mp4 and mkv files in user directory. The first 50 files will be skipped. Files will not be checked for valid video streams. Output will be recorded to \"/tmp/6x6 video wall.mp4\" instead of displaying on screen.\n\
\n"


## regex patterns ##

exp='^[0-9]+$'
word='^[a-z]|#([A-Fa-f0-9]{6})+$'


## config file ##

config="H4sICGr2KGICAy52aWRlb3dhbGwAVVNNTyMxDL33V1jtoVOpO7MIlgPSHFaq2AuL0IK4p4mnE8gk
UT5a+u/XTtoCl8k4tp+fn50FPOZpiwHcAMEdIjRwBT/g6hZWswVf9Dez2QI2OnojjjA5hXfgofEu
pCB0Wq3h6dOCQRuM4Kw5rsAFeIDGCKuiFB6/+lp4uFzrCGlEUDiIbFKp0M4WfPSeS/8JWoF0xuUA
lAQHrdII2oLXH2gixe4oop9vTUa4vp1zzqtW6IAZU2fNCfoOJr+n0s/ZM18YiCDdrGFvZCfps4Zh
4ByCrKl9t9W2q5cM+1d86ClPYC+SlZ6YrvjYa3US6/G7G5KD+K49hfHR/yyC5iCSdhaaiNKRFkRs
c5JAl5Sit7ZEXlud0DAtdcrqfzHGiwg7pD6CmBDIgdAImbIw1VDokYBJcZA+r2HnM2CSK8IZfOyv
C49/GFPQsk4O0tGXdsrZz9/8jhS6KZI+o8FzGCsnstIOmsT2WY8AXqTxeyfW1VBCLWd/VctKFxS4
nHxO3C2vQPQo9aBR1SqW2mrhyaCIZ9+R6RAS5fVdmny350EfhDEtORj4njPliPK9hd85uYn0kuQ/
QiSpDiPasmG0mcT2iQnmiIqWwrgDtRCToM3IPKsC0qeQsbQ/5mFghU4Dj9X+9KMIcizK1KEHlDlE
va+Du1iXhPOLEgSZCJimhIIQuEALr4K3WQoLW4QlK7FkwsskdsvyCpYGh1TvJNoUcNnW3jmW3ogx
nMm9gR5Y3YCnadRyBMRz5v9+TgYwXhn0vbP1bdRAVXny0pCj73IMXRxFwI7t2L283HcbfBOv+VnY
2KY0zP4D3IKnYlQEAAA="

if [[ ! -f $HOME/.videowall ]]; then
	base64 -d <<< "$config" | gzip -d > $HOME/.videowall && echo config file created
else
	. $HOME/.videowall
fi
font="${font:-/usr/share/fonts/TTF/Inconsolata-SemiBold.ttf}"
fontcolour="${fontcolour:-white}"

case $player in
	*cvlc) player=("$player" -q -f --key-quit 'q' --no-osd - --run-time=$duration "vlc://quit")
		;;
	*vlc) player=("$player" -q -f --key-quit 'q' --no-osd - --run-time=$duration "vlc://quit")
		;;
	*ffplay) player=("$player" -hide_banner -loglevel panic -autoexit -fs -)
		;;
	*mplayer) player=("$player" -fs -)
		;;
	*) player=(mpv --fullscreen --really-quiet -)
		;;
esac


## process options ##

while getopts :DrchSn:a:m:M:f:F:o:s:g:t:d: opts; do
   case "$opts" in
   h)	printf "$help"
		exit 0
      ;;
	n) rows=$OPTARG
		[[ ! $rows =~ $exp ]] && echo please specify a number from 1 to 16 for -n && exit
		(( rows > 16 )) && rows=16
		;;
	M) mode=$OPTARG
		;;
	m) maxvids=$OPTARG
		;;
	s) skip=$OPTARG
		;;
	F) fps=$OPTARG
		;;
	f) types=($OPTARG)
		;;
	g) grid="${OPTARG}"
		;;
	o) out="${OPTARG}"
		[[ ${out##*.} != mp4 ]] && echo please specify mp4 && exit
		;;
	a) audio="${OPTARG}"
		;;
	c) check=true
		;;
	S) shuffle=true
		;;
	r) recursive=true
		;;
	t) title="${OPTARG}"
		;;
	d) duration=${OPTARG}
		;;
	D) demo=(https://www.w3schools.com/html/mov_bbb.mp4)
		rows=3
		grid="#ff4400 5"
		;;
	:) echo $OPTARG requires argument
		exit 1
		;;
	*)	echo Option not recognised
		exit 1
		;;
	esac
done

shift $((OPTIND - 1))


## check for required applications ##

function required {
	hash $1 2>/dev/null || echo "Please install $1\n"
}
needed=(ffmpeg ffprobe xdpyinfo)
choose=(mpv vlc cvlc ffplay)
for app in ${needed[@]}; do
	alert+=$(required $app)
done
[[ -n $alert ]] && { printf "$alert"; exit 1; }

case "$mode" in
	p)	factor=2
	;;
	P)	check=true
		factor=2
	;;
	L)	check=true
	;;
esac


## graphics capabilities ##

cards=$(lspci | grep VGA)
nvidia=$(grep NVIDIA <<< "$cards")
intel=$(grep Intel <<< "$cards")

dims=$(xdpyinfo &>/dev/null | grep dimensions | awk '{print $2;}')
[[ -n $dims ]] && readarray -tdx wh <<< $dims
bw=${wh[0]:-1920}; bh=${wh[1]:-1080}


## initialise values ##

[[ -n $duration ]] && duration=(-t $duration)

fps=${fps:-30}

[[ -z $types ]] && types=(mp4 mkv mov ts webm avi wmv jpg jpeg png gif)

skip=${skip:-0}

num=0

factor=${factor:-1}

if [[ $factor == 2 ]]; then
	[[ $rows == 16 ]] && rows=15
	maxsides=${rows:-3}
else
	maxsides=${rows:-4}
fi
max=$(($maxsides*$maxsides*$factor))
[[ -z $maxvids ]] || ((maxvids > max)) && maxvids=$max

if [[ -n $title ]]; then
	title=($title)
	[[ ${#title[@]} != 2 ]] && echo "Please specify name/tag and left/centre for title" && exit
	if [[ ${title[0]} != name && ${title[0]} != tag ]]; then
		tmparr=(${title[1]} ${title[0]})
		title=(${tmparr[@]})
		if [[ ${title[0]} != name && ${title[0]} != tag ]]; then
			echo "Please specify 'name' or 'tag'" && exit
		elif [[ ${title[1]} != centre && ${title[1]} != left ]]; then
			echo "Please specify 'centre' or 'left'" && exit
		fi
	fi
fi


## build file list ##

input=$(echo $@ | sed -r 's/-[a-z]* ?|-F [a-z]* ?|-[a-z] [a-z]* ?//g')
[[ ${input: -1} == ' ' ]] && { echo "Please put options first"; exit; } #default=${default::-1}; }

function recurse() {
	for i in "$1"/*; do
		[[ -d "$i" ]] && recurse "$i" || { [[ -f "$i" ]] && vids+=("$i"); }
	done
}

[[ -z $input ]] &&
{ { [[ -n $demo ]] && vids=("$demo"); } || { [[ -n $recursive ]] && recurse $PWD || vids=(*); }; } ||
{ [[ -d $input ]] && { [[ -n $recursive ]] && recurse $input || vids=("$input"/*); } || vids=("$@"); }

for file in "${vids[@]}"; do
	if [[ $(( $num - $skip )) == $maxvids ]]; then
		break
	else
		ext="${file##*.}"
		if [[ -f "$file" && " ${types[@]} " =~ " $ext " || " ${types[@]} " =~ " ${ext,,} " || "${file:0:4}" == http ]]; then
			if [[ -n $check ]]; then
				checkfile=($(ffprobe -hide_banner -v panic -select_streams v:0 -show_entries "stream=codec_type,width,height:format_tags=title" \
-of default=noprint_wrappers=1 -i "$file"))
				[[ ${checkfile[0]##*=} != video ]] && continue
				thisw=${checkfile[1]##*=}
				thish=${checkfile[2]##*=}
				[[ $mode == L ]] && (( $thish > $thisw )) && continue
				[[ $mode == P ]] && (( $thisw > $thish )) && continue
				thistitle=$(grep "TAG:title" <<< "${checkfile[@]}")
				thistitle="${thistitle##*=}"
			fi
			((num++))
			(( $num <= $skip )) && continue
			if [[ -n $title ]]; then
				if [[ ${title[1]} == tag && -n $thistitle ]]; then
					t="${thistitle//\'/â€™}"
					t="${t//\:/-}"
					unset thistitle
				else
					t="${file##*/}"
					t="${t%.$ext}"
				fi
				titles+=("'${t:0:36}'")
			else
				titles+=("")
			fi
			inputs+=(-stream_loop -1 -i "${file}")
			files+=("${file}")
		fi
	fi
done

[[ -z $files ]] && echo No files found && exit

(( num-=$skip ))

if [[ $((max-num)) > 0 ]]; then
	f=0
	for i in $(seq 0 $((max-num-1))); do
		files+=("${files[$f]}")
		titles+=("${titles[$f]}")
		inputs+=(-stream_loop -1 -i "${files[$f]}")
		((f++))
		(( f >= num )) && f=0
	done
	num=$max
fi

if [[ -n $shuffle ]]; then
	while read numtitles; do
		sfiles+=("${files[$numtitles]}")
		stitles+=("${titles[$numtitles]}")
		sinputs+=(-stream_loop -1 -i "${files[$numtitles]}")
	done < <(
		seq 0 $((${#titles[@]}-1)) | shuf
	)
	files=("${sfiles[@]}")
	titles=("${stitles[@]}")
	inputs=("${sinputs[@]}")
fi

(( $num < 1 )) || [[ -z $num ]] && { echo No valid files; exit; }

numf=$(( (num+factor-1)/factor ))
for (( i=0; i<=$maxsides; i++ )); do
	n=$((i*i))
	m=$(((i+1)*(i+1)))
	(( $numf == $n )) && { max=$n; break; }
	(( $numf > $n && $numf < $m )) && { max=$m; break; }
done

sides=$(echo "sqrt($max)" | bc)
w0=0; w1=$((bw/sides/$factor))
h0=0; h1=$((bh/sides))
for (( i=2; i<=$((maxsides*factor)); i++ )); do
	width=w$i; wval=$((w1*$i))
	eval "${width}=\${wval}";
	height=h$i; hval=$((h1*$i))
	eval "${height}=\${hval}";
done


## create overlay parameters ##

for ((i=0;i<$sides;i++)); do
	for ((j=0;j<$((sides*factor));j++)); do
		x=$j; x=w$((x++))
		y=$i; y=h$y
		coords+=(x=${!x}:y=${!y})
	done
done

if [[ -n $grid ]]; then
	grid=($grid)
	[[ ! ${grid[0]} =~ $word && ! ${grid[1]} =~ $word ]] || [[ ! ${grid[0]} =~ $exp && ! ${grid[1]} =~ $exp ]] && echo "grid requires colour (name or full hex value) and integer" && exit
	[[ ${grid[0]} =~ $exp || ${grid[1]} =~ $word ]] && { tmparr=(${grid[1]} ${grid[0]}); grid=(${tmparr[@]}); }
	pos=$((${grid[1]}+4))
	grid=",drawbox=0:0:0:0:${grid[0]}:t=${grid[1]}"
fi

[[ ${title[1]} == centre ]] && position=": x=(w-text_w)/2: y=(h-text_h)/2+$((4*$h1/10))" || position=": x=${pos:-4}: y=${pos:-4}"

ptsize=$(($w1/20))

sc="scale=${w1}x${h1}"

dt1="drawtext=fontfile=${font}:text="
dt2=": fontcolor=${fontcolour}: fontsize=$ptsize: box=1: boxcolor=black@0.3: boxborderw=6$position$grid"

fc="color=c=black:size=${bw}x${bh}[base];"

for vid in "${!titles[@]}"; do
	vid1=$(($vid+1))
	fc+="[$vid:v]fps=$fps,$sc,$dt1${titles[$vid]}$dt2[$vid1];"
	vid2=$(($vid+2))
	if [[ $vid -lt $(($num-1)) ]]; then
		[[ $vid == 0 ]] && fc+="[base][$vid1]overlay=${coords[$vid]}[tmp$vid1];" || fc+="[tmp$vid][$vid1]overlay=${coords[$vid]}[tmp$vid1];"
	else
		[[ $num == 1 ]] && fc+="[base][$vid1]overlay=${coords[$vid]}" || fc+="[tmp$vid][$vid1]overlay=${coords[$vid]}"
	fi
done


## ffmpeg codec parameters ##

if [[ -n $audio ]]; then
	[[ $audio =~ $exp ]] &&
		{ (( $audio > $num )) && { echo audio index out of range; exit; }; anum=$((--audio)); audio="${files[$anum]}"; }
	ainput=(-stream_loop -1 -i "$audio")
	aoutput=(-map "$num:a")
else
	aoutput=-an
fi

[[ -n $nvidia ]] && opts=(-c:v h264_nvenc -r $fps \
   -b:v 3M -maxrate:v 5M -bufsize:v 8M -profile:v main -preset:v p1 -tune:v ull \
   -level:v 4.2 -rc:v vbr -bf:v 3 -coder:v cabac ${aoutput[@]}) || opts=(-c:v libx264 -r $fps -crf 18 -preset slow ${aoutput[@]})
#opts=(-c:v libx265 -r $fps -x265-params lossless=1 ${aoutput[@]})


## build ffmpeg command ##

cmd=(ffmpeg -hide_banner -loglevel panic "${inputs[@]}" -filter_complex "$fc" "${ainput[@]}" ${duration[@]} ${opts[@]})


## record or display ##

[[ -n $out ]] && "${cmd[@]}" -f mp4 "$out" || "${cmd[@]}" -f matroska pipe: | "${player[@]}" 2>/dev/null

[[ $? != 0 ]] && echo bad options or missing video streams
